---
name: systematic-debugging
description: 四阶段调试方法论，强调根因分析。用于调查 bug、修复测试失败、排查异常行为。核心原则：不先找到根因，就不要尝试修复。
---

# 系统性调试 (Systematic Debugging)

## 核心原则

**🚫 不调查根因，就不修复！**

永远不要用"症状修复补丁"来掩盖底层问题。在尝试修复之前，先理解**为什么**会失败。

## 四阶段框架

### 阶段 1: 根因调查 (Root Cause Investigation)

在动任何代码之前：

1. **仔细阅读错误信息** - 每个字都重要
2. **稳定复现问题** - 无法复现就无法验证修复
3. **检查最近改动** - 问题出现前改了什么？
4. **收集诊断证据** - 日志、堆栈、状态快照
5. **追踪数据流** - 沿着调用链找到错误值的源头

**根因追踪技术:**
```
1. 观察症状 - 错误在哪里显现？
2. 找直接原因 - 哪行代码直接产生了错误？
3. 问"谁调用了它？" - 向上映射调用链
4. 继续向上追踪 - 跟踪无效数据在堆栈中回溯
5. 找到原始触发点 - 问题实际从哪里开始？
```

**关键原则:** 永远不要只在错误显现的地方修复——必须追溯到原始触发点。

### 阶段 2: 模式分析 (Pattern Analysis)

1. **找到正常工作的例子** - 找类似但正常的代码
2. **完整对比实现** - 不要只是略读
3. **识别差异** - 正常和异常之间有什么不同？
4. **理解依赖** - 这段代码依赖什么？

### 阶段 3: 假设与测试 (Hypothesis and Testing)

应用科学方法：

1. **形成一个清晰假设** - "错误发生是因为 X"
2. **设计最小测试** - 每次只改变一个变量
3. **预测结果** - 如果假设正确，应该发生什么？
4. **执行测试** - 运行并观察
5. **验证结果** - 是否按预期行为？
6. **迭代或继续** - 假设错误则修正，正确则实施

### 阶段 4: 实施修复 (Implementation)

1. **创建失败测试用例** - 捕获 bug 行为
2. **实施单一修复** - 针对根因，不是症状
3. **验证测试通过** - 确认修复有效
4. **运行完整测试套件** - 确保无回归
5. **如果修复失败，停下来** - 重新评估假设
6. **🚨 配置驱动检查** - 修复必须符合配置驱动开发原则

**关键规则:** 如果连续 3 次以上修复尝试失败，**立即停止**。这表明存在架构问题，需要讨论，而不是继续打补丁。

### 🚨 配置驱动修复检查 (Config-Driven Fix Validation)

基于 `.claude/skills/config-driven-dev/` 的设计理念，每次修复必须检查：

#### 修复前必问
- [ ] 这个 bug 是否因为硬编码导致？→ 应抽成配置
- [ ] 这个行为未来是否可能需要"关掉/调小/调大"？→ 应可配置
- [ ] 这个阈值/限制是否写死在代码里？→ 应抽成配置
- [ ] 这个开关/特性是否可以通过配置控制？

#### 修复时必须遵守
```typescript
// ❌ 错误的修复方式 - 硬编码修复
const TIMEOUT = 10000  // 从 5000 改成 10000
const MAX_RETRIES = 5  // 从 3 改成 5

// ✅ 正确的修复方式 - 配置驱动
const config = getConfig()
const timeout = config.timeout ?? 5000      // 配置优先，有安全默认值
const maxRetries = config.maxRetries ?? 3   // 配置优先，有安全默认值
```

#### 配置驱动修复流程
```
1. 识别问题是否与可配置参数相关
2. 如果是：
   a. 检查是否已有配置项 → 调整默认值或文档
   b. 如果没有 → 新增配置项（类型/默认值/范围/描述）
3. 确保配置集中读取，不分散在业务代码中
4. 考虑是否需要支持运行时热更新
5. 更新配置 schema 和文档
```

#### 配置项设计标准
```typescript
interface FixConfig {
  /** 描述: 这个配置控制什么 */
  configName: ConfigType       // 类型: boolean/number/string/array
                               // 默认值: 安全、保守的值
                               // 范围: min/max 或枚举值
                               // 描述: 清晰说明影响
}
```

#### 常见配置驱动修复场景

| Bug 类型 | 硬编码修复(❌) | 配置驱动修复(✅) |
|---------|-------------|---------------|
| 超时问题 | 改 TIMEOUT 常量 | 新增 `config.timeout` |
| 重试失败 | 改 MAX_RETRIES | 新增 `config.maxRetries` |
| 批量处理慢 | 改 BATCH_SIZE | 新增 `config.batchSize` |
| 特性开关 | 改 if 条件 | 新增 `config.features.xxx.enabled` |
| 过滤规则 | 改正则表达式 | 新增 `config.excludePatterns` |

## 🚩 红旗 - 过程违规

如果你发现自己在想：

- ❌ "先快速修一下，以后再调查"
- ❌ "再试一次修复"（在多次失败后）
- ❌ "这应该能工作"（没有理解为什么）
- ❌ "让我试试..."（没有假设）
- ❌ "在我机器上能跑"（没有调查差异）

**立即停止！** 回到阶段 1。

## ⚠️ 深层问题的警告信号

**连续修复在不同区域暴露新问题** 表明存在架构问题：

- 停止打补丁
- 记录你发现的内容
- 与团队讨论后再继续
- 考虑设计是否需要重新思考

## 常见调试场景

### 测试失败
```
1. 读完整的错误消息和堆栈跟踪
2. 识别哪个断言失败以及为什么
3. 检查测试设置 - 测试环境正确吗？
4. 检查测试数据 - mock/fixture 正确吗？
5. 追溯到意外值的来源
```

### 运行时错误
```
1. 捕获完整堆栈跟踪
2. 识别抛出错误的行
3. 检查哪些值是 undefined/null
4. 向后追溯找到错误值的来源
5. 在源头添加验证
```

### "之前能跑"
```
1. 用 git bisect 找到引入问题的提交
2. 对比改动与之前正常的版本
3. 识别哪个假设改变了
4. 在假设违反的源头修复
```

### 间歇性失败
```
1. 查找竞态条件
2. 检查共享可变状态
3. 检查异步操作顺序
4. 查找时序依赖
5. 添加确定性等待或正确的同步
```

## OpenClaw CN 特定调试

### 渠道消息问题
```
1. 检查回调签名验证
2. 检查消息加解密
3. 检查 Token 是否过期
4. 检查消息格式是否符合渠道规范
5. 查看渠道 API 返回的错误码
```

### 配置问题
```
1. 检查 openclaw.json 配置格式
2. 验证环境变量是否设置
3. 检查配置 schema 验证
4. 查看配置加载日志
5. 对比默认值与实际值
```

### Gateway/WebSocket 问题
```
1. 检查连接状态
2. 检查心跳是否正常
3. 检查消息序列化/反序列化
4. 查看网络层错误
5. 检查重连逻辑
```

## 调试检查清单

在声称 bug 已修复之前：

- [ ] 根因已识别并记录
- [ ] 假设已形成并测试
- [ ] 修复针对根因，不是症状
- [ ] 创建了复现 bug 的失败测试
- [ ] 测试现在通过
- [ ] 完整测试套件通过
- [ ] 没有使用"快速修复"借口
- [ ] 修复是最小化和聚焦的
- [ ] **符合配置驱动开发原则**（如适用）

## 成功指标

系统性调试的首次修复成功率约 **95%**，而随意调试只有约 **40%**。

做对了的迹象：
- 修复不会产生新 bug
- 你能解释**为什么**会发生这个 bug
- 类似 bug 不会再次出现
- 修复后代码更好，而不只是"能跑"

## 调试命令

```bash
# 查看最近的改动
git --no-pager log --oneline -10
git --no-pager diff HEAD~1

# 找到引入问题的提交
git bisect start
git bisect bad HEAD
git bisect good <known-good-commit>

# 查看特定文件的改动历史
git --no-pager log -p --follow -- path/to/file.ts

# 运行单个测试
pnpm test -- --grep "test name"

# 查看 TypeScript 类型错误
pnpm tsc --noEmit

# 查看运行时日志
DEBUG=* pnpm dev
```
